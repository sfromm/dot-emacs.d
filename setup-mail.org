#+TITLE: Emacs Mail Configuration
#+PROPERTY: header-args :tangle ~/.emacs.d/site-lisp/setup-mail.el

* Message mode

Set up =message-mode=.  This will kill the buffer after sending an email
and set preferences for message citation and how to forward an
email. For more on configuring Emacs =message-mode=, see the [[https://www.gnu.org/software/emacs/manual/html_mono/message.html][manual]].
Use SMTP for sending email instead of a local sendmail binary.

#+BEGIN_SRC emacs-lisp
  (setq
    mail-from-style 'angles
    message-kill-buffer-on-exit t
    message-citation-line-format "On %a, %Y-%m-%d at %T %z, %N wrote:"
    message-citation-line-function (quote message-insert-formatted-citation-line)
    message-make-forward-subject-function (quote message-forward-subject-fwd)
    message-signature t
    message-signature-file "~/.signature"
    message-send-mail-function 'smtpmail-send-it
    mime-view-text/html-previewer 'shr
    mm-text-html-renderer 'shr
    mm-inline-text-html-with-images nil
    mm-inline-large-images nil
    mm-discouraged-alternatives '("text/html" "text/richtext")
  ;;  mm-automatic-display (remove "text/html" mm-automatic-display))
    shr-inhibit-images nil
    )
#+END_SRC

Enable certain modes for *message-mode*:

#+BEGIN_SRC emacs-lisp
  (add-hook 'message-mode-hook 'footnote-mode)
  (add-hook 'message-mode-hook 'turn-on-flyspell)
  (add-hook 'message-mode-hook #'yas-minor-mode)
  (add-hook 'message-mode-hook
    'turn-on-auto-fill
    (lambda()
      (auto-fill-mode t)
      (setq fill-column 72)
      (setq mail-header-separator "")
      )
    )
#+END_SRC

Knobs for encryption:

#+BEGIN_SRC emacs-lisp
  (setq
    mml2015-signers '("A852499F") ; key to use for signing email
    mml2015-encrypt-to-self t)    ; also encrypt to self when sending email
#+END_SRC

* Sending email

The following configures default SMTP settings for =smtpmail=.

#+BEGIN_SRC emacs-lisp
  (use-package smtpmail
    :defer t
    :config
    (setq
      smtpmail-stream-type 'ssl
      smtpmail-default-smtp-server sf-custom/smtp-server-work
      smtpmail-smtp-server sf-custom/smtp-server-work
      smtpmail-smtp-service 465
      smtpmail-smtp-user sf-custom/smtp-user-work
      smtpmail-queue-dir (expand-file-name (concat user-emacs-directory "user/queue"))
      ))
#+END_SRC

Be sure to use an encrypted /authinfo/ file.

#+BEGIN_SRC emacs-lisp
(setq smtpmail-auth-credentials "~/.authinfo.gpg")
#+END_SRC

Use /dired/ to attach files to messages.

#+BEGIN_SRC emacs-lisp
(require 'gnus-dired)
(add-hook 'dired-mode-hook 'turn-on-gnus-dired-mode)
#+END_SRC

* Mu Emacs MUA

[[http://www.djcbsoftware.nl/code/mu/mu4e.html][mu4e]] is an emacs-based email client that uses [[http://www.djcbsoftware.nl/code/mu/][mu]] as its backend.  There
is also a [[https://groups.google.com/forum/#!forum/mu-discuss][mailing list]].

#+BEGIN_SRC emacs-lisp :noweb yes
(use-package mu4e
  :if (executable-find "mu")
  :commands mu4e
  :init
  (progn
    (require 'mu4e-contrib)
    (require 'org-mu4e)

    ;; default to emacs mode - not vim emulation
    (dolist (mode '(mu4e-main-mode mu4e-compose-mode mu4e-headers-mode mu4e-view-mode))
      (evil-set-initial-state mode 'emacs))

    ;; set up default maildir paths and folders
    (setq
      mu4e-attachment-dir "~/Download"
      mu4e-maildir (expand-file-name "~/.mail")
      mu4e-sent-folder   (lambda (msg)
                           (sf/mu4e-folder-for (sf/mu4e-msg-current-account msg) "Sent"))
      mu4e-drafts-folder (lambda (msg)
                           (sf/mu4e-folder-for (sf/mu4e-msg-current-account msg) "Drafts"))
      mu4e-trash-folder  (lambda (msg)
                           (sf/mu4e-folder-for (sf/mu4e-msg-current-account msg) "Trash"))
      mu4e-refile-folder (lambda (msg)
                           (sf/mu4e-folder-for (sf/mu4e-msg-current-account msg) "Archive")))

    ;; general options
    (setq
      mu4e-get-mail-command "mbsync -a"
      mu4e-update-interval 180              ;; check for updates every 3 min
      mu4e-index-lazy-check t               ;; do a lazy check on whether a message should be (re)indexed.
      mu4e-use-fancy-chars t
      mu4e-auto-retrieve-keys t             ;; try to automatically retrieve public keys
      mu4e-compose-dont-reply-to-self t
      mu4e-compose-signature-auto-include t
      mu4e-change-filenames-when-moving t   ;; new filenames when moving; needed for mbsync
      mu4e-completing-read-function 'ivy-completing-read
      gnus-dired-mail-mode 'mu4e-user-agent)

    ;; bookmarks
    (setq mu4e-bookmarks '(
                            ("flag:unread AND NOT flag:trashed" "Unread messages" ?u)
                            ("maildir:/Personal/INBOX OR maildir:/Work/INBOX" "ONE Inbox" ?I)
                            ("flag:flagged" "Flagged" ?f)
                            ("date:1d..now and flag:unread and not maildir:/Work/Trash"  "Today's messages" ?t)
                            ("date:3d..now and flag:unread and not maildir:/Work/Trash"  "Last 3 days" ?3)
                            ("date:14d..now and flag:unread and not maildir:/Work/Trash" "Last 14 days" ?4)
                            ("( m:/Work/ and ( flag:flagged or flag:unread ) ) or m:/Work/INBOX" "Work" ?w)
                            ("m:/lists/ and flag:unread" "Unread lists" ?l)
                            ("m:/ops/ and flag:unread" "Unread Ops" ?o)
                            ("flag:attach"   "With attachments" ?A)
                            ("mime:text/calendar" "Meeting invites" ?c)))
    ;; maildir shortcuts
    (setq mu4e-maildir-shortcuts '(
                                    ("/Work/INBOX" . ?I)
                                    ("/Work/incoming" . ?i)
                                    ("/Work/ops"      . ?o)
                                    ("/Work/lists"    . ?l)
                                    ("/Work/Sent"     . ?S)))

    <<mu4e-accounts>>
    <<mu4e-headers>>
    <<mu4e-headers-marks>>
    <<mu4e-view>>
    ))
#+END_SRC

** Accounts

This is the old-style mechanism for switching between accounts, as described in the [[http://www.djcbsoftware.nl/code/mu/mu4e/Multiple-accounts.html#Multiple-accounts][manual]].

This also takes quite a bit of function helpers from [[https://writequit.org/][Lee Hinman]]'s [[https://writequit.org/eos/eos-mail.html][eos mail]] configuration.  In
particular, this takes the functions to help sort out what account to use for archiving, composing,
and so on.

#+NAME: mu4e-accounts
#+BEGIN_SRC emacs-lisp :tangle no
(defvar sf/mu4e-account-alist nil "An alist of account information for mu4e.")

(setq sf/mu4e-account-alist
  `(("Work"
      (user-mail-address ,sf-custom/email-work)
      (smtpmail-smtp-user ,sf-custom/smtp-user-work)
      (smtpmail-smtp-server ,sf-custom/smtp-server-work)
      (smtpmail-stream-type ssl)
      (smtpmail-smtp-service 465))
     ("Personal"
       (user-mail-address ,sf-custom/email-personal)
       (smtpmail-smtp-user ,sf-custom/smtp-user-personal)
       (smtpmail-smtp-server ,sf-custom/smtp-server-personal)
       (smtpmail-stream-type starttls)
       (smtpmail-smtp-service 587))))

(defun sf/mu4e-folder-for (acct folder)
  "Return path to folder name.  Requires ACCT and FOLDER."
  (if (and (string= "Archive" folder) (string= "Work" acct))
    (format "/%s/%s.%s" acct folder (format-time-string "%Y"))
    (format "/%s/%s" acct folder)))

(defun sf/mu4e-msg-current-account (&optional msg ignore)
  "Determine the account current message (optionally MSG) is part of.
Supports ignoring IGNORE message at point."
  (let ((cur-msg (or msg
                   mu4e-compose-parent-message
                   (and (not ignore)
                     (mu4e-message-at-point t)))))
    (when cur-msg
      (let ((maildir (mu4e-msg-field cur-msg :maildir)))
        (string-match "/\\(.*?\\)/" maildir)
        (match-string 1 maildir)))))

(defun sf/mu4e-choose-account ()
  "Prompt for account to use."
  (completing-read (format "Compose with account: (%s) "
                     (mapconcat #'(lambda (var) (car var))
                       sf/mu4e-account-alist "/"))
    (mapcar #'(lambda (var) (car var)) sf/mu4e-account-alist)
    nil t nil nil (caar sf/mu4e-account-alist)))

(defun sf/mu4e-set-compose-account ()
  "Set the account for composing a message."
  (let* ((account (or (sf/mu4e-msg-current-account nil t)
                    (sf/mu4e-choose-account)))
          (account-vars (cdr (assoc account sf/mu4e-account-alist))))
    (when account-vars
      (mapc #'(lambda (var)
                (set (car var) (cadr var)))
        account-vars))))

  (add-hook 'mu4e-compose-pre-hook 'sf/mu4e-set-compose-account)
#+END_SRC

** Contexts

[[http://www.djcbsoftware.nl/code/mu/mu4e.html][mu4e]] uses [[https://www.djcbsoftware.nl/code/mu/mu4e/Contexts.html][contexts]] to switch between different sets of settings.  This
is especially useful for using personal and work email accounts.

#+NAME: mu4e-contexts
#+BEGIN_SRC emacs-lisp :tangle no
  (setq
    mu4e-context-policy 'pick-first
    mu4e-contexts `(
                     ,(make-mu4e-context
                        :name "Work"
                        :enter-func (lambda () (mu4e-message "Switch to Work context"))
                        :match-func (lambda (msg)
                                      (when msg
                                        (mu4e-message-contact-field-matches msg
                                          :to sf-custom/email-work)))
                        :vars `(
                                 (user-mail-address      . ,sf-custom/email-work)
                                 (mu4e-sent-folder       . "/Work/Sent")
                                 (mu4e-drafts-folder     . "/Work/Drafts")
                                 (mu4e-trash-folder      . "/Work/Trash")
                                 (mu4e-compose-signature . (get-string-from-file (expand-file-name "~/.signature")))
                                 (smtpmail-smtp-user    . ,sf-custom/smtp-user-work)
                                 (smtpmail-smtp-server  . ,sf-custom/smtp-server-work)
                                 (smtpmail-stream-type  . ssl)
                                 (smtpmail-smtp-service . 465)
                                 ))
                     ,(make-mu4e-context
                        :name "Personal"
                        :enter-func (lambda () (mu4e-message "Switch to Personal context"))
                        :match-func (lambda (msg)
                                      (when msg
                                        (mu4e-message-contact-field-matches msg
                                          :to sf-custom/email-personal)))
                        :vars `(
                                 (user-mail-address . ,sf-custom/email-personal)
                                 (mu4e-sent-folder . "/Personal/Sent")
                                 (mu4e-drafts-folder . "/Personal/Drafts")
                                 (mu4e-trash-folder . "/Personal/Trash")
                                 (mu4e-compose-signature . user-full-name)
                                 (smtpmail-smtp-user . ,sf-custom/smtp-user-personal)
                                 (smtpmail-smtp-server . ,sf-custom/smtp-server-personal)
                                 (smtpmail-stream-type . ssl)
                                 (smtpmail-smtp-service . 465)
                                 ))
                     ))
#+END_SRC

** mu4e Headers configuration

The following is to change the behavior of [[http://www.djcbsoftware.nl/code/mu/mu4e.html][mu4e]] so that when email is
"trashed", it is just moved to the trash folder.  I don't want it to
also add the /trash/ maildir flag.

/mu4e-marks/ is defined in [[https://github.com/djcb/mu/blob/master/mu4e/mu4e-mark.el][mu4e-mark.el]].

#+NAME: mu4e-headers-marks
#+BEGIN_SRC emacs-lisp :tangle no
  (setq mu4e-marks (assq-delete-all 'trash mu4e-marks))
  (push '(trash
           :char ("d" . "▼")
           :prompt "dtrash"
           :dyn-target (lambda
                         (target msg)
                         (mu4e-get-trash-folder msg))
           :action (lambda
                     (docid msg target)
                     (mu4e~proc-move docid
                       (mu4e~mark-check-target target) "+S-u-N"))) mu4e-marks)
#+END_SRC

Configuration when listing messages.

#+NAME: mu4e-headers
#+BEGIN_SRC emacs-lisp :tangle no
(setq
  mu4e-headers-from-or-to-prefix '("" . "➜ ")
  mu4e-headers-results-limit 750
  mu4e-headers-include-related nil
  mu4e-headers-fields '(
                         (:human-date . 12)
                         (:flags . 6)
                         (:mailing-list . 10)
                         (:from-or-to . 22)
                         (:thread-subject)))

(add-to-list 'mu4e-headers-actions
  '("capture message" . mu4e-action-capture-message) t)
(add-to-list 'mu4e-headers-actions
  '("show thread" . mu4e-action-show-thread) t)
(add-to-list 'mu4e-headers-actions
  '("tag message" . mu4e-action-retag-message) t)

(define-key mu4e-headers-mode-map (kbd "f") 'sf/mu4e-forward-as-attachment)
(define-key mu4e-headers-mode-map (kbd "y") 'mu4e-headers-mark-for-refile)
(define-key mu4e-headers-mode-map (kbd "B") 'sf/mu4e-bounce-message)
(define-key mu4e-headers-mode-map (kbd "J") 'sf/mu4e-trash-add-sender-bulkdb)
#+END_SRC

** mu4e View Configuration

Configuration when viewing messages.

#+NAME: mu4e-view
#+BEGIN_SRC emacs-lisp :tangle no
(setq
  mu4e-view-scroll-to-next nil          ;; do not advance to next message when scolling
  mu4e-view-show-images t               ;; show images inline
  mu4e-view-show-addresses t            ;; always show full email address
  mu4e-view-prefer-html t
  mu4e-html2text-command 'mu4e-shr2text)

(add-to-list 'mu4e-view-actions '("capture message" . mu4e-action-capture-message) t)
(add-to-list 'mu4e-view-actions '("browse email" . mu4e-action-view-in-browser) t)
(add-to-list 'mu4e-view-actions '("view as pdf" . mu4e-action-view-as-pdf) t)
(add-to-list 'mu4e-view-actions '("tag message" . mu4e-action-retag-message) t)
(add-to-list 'mu4e-view-actions '("show thread" . mu4e-action-show-thread) t)

(add-to-list 'mu4e-view-attachment-actions '("gcal-import" . sf/mu4e-view-gcal-attachment) t)

(define-key mu4e-view-mode-map (kbd "f") 'sf/mu4e-forward-as-attachment)
(define-key mu4e-view-mode-map (kbd "y") 'mu4e-view-mark-for-refile)
(define-key mu4e-view-mode-map (kbd "J") 'sf/mu4e-trash-add-sender-bulkdb)

;; use imagemagick if possible to help with display of images
(when (fboundp 'imagemagick-register-types)
  (imagemagick-register-types))
#+END_SRC

** mu4e Forward Emails

I prefer to forward emails as attachments instead of inline; mu4e
defaults to inline.  To forward as an attachment, mu4e provides a
mechanism where you capture the message with =mu4e-capture-message=,
start a new message, and then use =mu4e-compose-attach-captured-message=.

In lieu of that, this will get the message at point and then attach
the maildir message as message/rfc822.  This adds the /References/
header, which appears to set the /Passed/ flag.

For issues with /invalid RFC822/ characters, see:

- https://github.com/djcb/mu/issues/1019
- https://groups.google.com/forum/#!topic/mu-discuss/FJo0GmRl4Uo

#+BEGIN_SRC emacs-lisp
  (defun sf/mu4e-forward-as-attachment ()
    "Forward message as an attachment"
    (interactive)
    (let ((msgid (mu4e-message-field (mu4e-message-at-point t) :message-id))
           (path (mu4e-message-field (mu4e-message-at-point t) :path))
           forward-subject)
      (mu4e-compose 'new)
      (let ((temp-buffer (get-buffer-create (concat "*sf-fwd-mail-" msgid "*"))))
        ;; this comes from notmuch-mua.el
        ;; insert the mail file into a temporary buffer
        ;; then call message-forward-make-body on that temp buffer.
        (with-current-buffer temp-buffer
          (erase-buffer)
          (let ((coding-system-for-read 'no-conversion))
            (insert-file-contents path))
          (setq forward-subject (message-make-forward-subject)))
        (goto-char (point-max))
        (message-forward-make-body temp-buffer)
        (kill-buffer temp-buffer)
        ;; Update the Subject header and add a References header.
        (save-restriction
          (message-narrow-to-headers)
          (message-remove-header "Subject")
          (message-add-header (concat "Subject: " forward-subject))
          (message-add-header (concat "References: <" msgid ">")))
        (message-goto-to)
        )))
#+END_SRC

Forward an abuse complaint.

#+BEGIN_SRC emacs-lisp
  (defun sf/mail-forward-abuse-complaint ()
    "Forward an abuse complaint to responsible party"
    (interactive)
    (sf/mu4e-forward-as-attachment)
    (message-goto-body)
    (yas-expand-snippet (yas-lookup-snippet "abuse-template"))
    (message-add-header (concat "Cc: " sf-custom/abuse-mail-cc))
    (message-goto-to))
#+END_SRC

Forward an infringement complaint.

#+BEGIN_SRC emacs-lisp
  (defun sf/mail-forward-infringement-complaint ()
    "Forward a infringement complaint to responsible party"
    (interactive)
    (sf/mu4e-forward-as-attachment)
    (message-goto-body)
    (yas-expand-snippet (yas-lookup-snippet "infringement-template"))
    (message-add-header (concat "Cc: " sf-custom/abuse-mail-cc))
    (message-goto-to))
#+END_SRC

Forward a spam complaint.

#+BEGIN_SRC emacs-lisp
  (defun sf/mail-forward-spam-complaint ()
    "Forward a spam complaint to responsible party"
    (interactive)
    (sf/mu4e-forward-as-attachment)
    (message-goto-body)
    (yas-expand-snippet (yas-lookup-snippet "spam-template"))
    (message-add-header (concat "Cc: " sf-custom/abuse-mail-cc))
    (message-goto-to))
#+END_SRC

This bounces a message - ie. add a Resend-To header.

#+BEGIN_SRC emacs-lisp
  (defun sf/mu4e-bounce-message (address)
    "Bounce message at point to a recipient. See https://github.com/djcb/mu/pull/449/files"
    (interactive "sBounce to: ")
    (let ((path (plist-get (mu4e-message-at-point t) :path)))
      (unless (and path (file-readable-p path))
        (mu4e-error "Not a readable file: %S" path))
      (find-file path)
      (mu4e-compose-mode)
      (make-local-variable 'mu4e-sent-messages-behavior)
      (setq mu4e-sent-messages-behavior 'sent)
      (message-resend address)
      (kill-buffer)
      )
    )
#+END_SRC

Put together a hydra to make it easy to access the functionality.

#+BEGIN_SRC emacs-lisp
  (defhydra sf/hydra-email (:color blue)
      "
    _f_ Forward email         _N_ Toggle compose New frame
    _A_ Forward Abuse report  _S_ Forward Spam report
    _I_ Forward Infringement  _e_ Extract all attachments
    "
      ("f" sf/mu4e-forward-as-attachment)
      ("A" sf/mail-forward-abuse-complaint)
      ("I" sf/mail-forward-infringement-complaint)
      ("S" sf/mail-forward-spam-complaint)
      ("N" sf/mail-toggle-compose-new-frame)
      ("e" sf/mu4e-save-all-attachments))

  (global-set-key (kbd "C-c m") 'sf/hydra-email/body)
#+END_SRC

** mu4e Helper Functions

The following are miscellaneous helper functions.

The first function =sf/mu4e-refile-folder= is based on the example from
the [[http://www.djcbsoftware.nl/code/mu/mu4e/index.html][mu4e manual]] [[http://www.djcbsoftware.nl/code/mu/mu4e/Tips-and-Tricks.html][Tips and Tricks]] section on [[http://www.djcbsoftware.nl/code/mu/mu4e/Refiling-messages.html][refiling messages]].

#+BEGIN_SRC emacs-lisp
  (defun sf/mu4e-refile-folder (msg)
    "Set the refile folder for MSG.  Looks at several alists to evaluate how best to refile."
    (cond
      ((string-match "Work" (mu4e-message-field msg :maildir))
        (cond
          ((catch 'found
             (dolist (subject sf/mu4e-refile-work-by-subject)
               (if (string-match (car subject) (mu4e-message-field msg :subject))
                 (throw 'found (cdr subject))))))
          ((catch 'found
             (dolist (contact sf/mu4e-refile-work-by-contact)
               (if (mu4e-message-contact-field-matches msg '(:to :from :cc :bcc) (car contact))
                 (throw 'found (cdr contact))))))
          (t (concat "/Work/Archive." (format-time-string "%Y")))))
      ((string-match "Personal" (mu4e-message-field msg :maildir))
        (cond
          ((catch 'found
             (dolist (contact sf/mu4e-refile-personal-by-contact)
               (if (mu4e-message-contact-field-matches msg '(:to :from :cc :bcc) (car contact))
                 (throw 'found (cdr contact))))))
          (t "/Personal/Archive")))
      ))
#+END_SRC

This is to get automatic tagging.  The idea is that the two variables are populated with an alist
that describes tags for subjects or contacts.  The total list is then used to retag the message.
This method is then added to the =mu4e-mark-execute-pre-hook=.  The goal is to facilitate searching
for mail when it is in the archive.

#+BEGIN_SRC emacs-lisp
(defvar sf/mu4e-retag-work-by-subject '() "List of subjects to retag work email.")

(defvar sf/mu4e-retag-work-by-contact '() "List of contacts to retag work email.")

(defun sf/mu4e-retag-msg (mark msg)
  "Takes MARK and MSG as arguments.
This function will tag the message according to a set of rules.
This is intended to be added to the `mu4e-mark-execute-pre-hook'
hook so that messages are automatically tagged."
  (let ((tags '()))
    (cond
      ((string-match "Work" (mu4e-message-field msg :maildir))
        (dolist (subject sf/mu4e-retag-work-by-subject)
          (if (string-match (car subject) (mu4e-message-field msg :subject))
            (setq tags (cons (cdr subject) tags))))
        (dolist (contact sf/mu4e-retag-work-by-contact)
          (if (mu4e-message-contact-field-matches msg '(:to :from :cc :bcc) (car contact))
            (setq tags (cons (cdr contact) tags))))))
    ;; take the tags list, join with commas, and provide as argument
    ;; to mu4e-action-retag-message.
    (mu4e-action-retag-message msg (mapconcat 'identity tags ","))))

(add-hook 'mu4e-mark-execute-pre-hook #'sf/mu4e-retag-msg)
#+END_SRC

Extract a header from an email message.

#+BEGIN_SRC emacs-lisp
(defun sf/mu4e-get-message-header (msg header)
  "Extract header from message"
     (replace-regexp-in-string "\n$" ""
         (shell-command-to-string
           (concat "mail-get-header.py -H " header " -p " (shell-quote-argument (mu4e-message-field msg :path))))))
#+END_SRC

Toggle whether to compose in a new frame.

#+BEGIN_SRC emacs-lisp
(defun sf/mail-toggle-compose-new-frame ()
  "Toggle whether to compose email in new frame."
  (interactive)
  (if (boundp 'notmuch-mua-compose-in)
    (if (eq notmuch-mua-compose-in 'current-window)
      (setq notmuch-mua-compose-in 'new-frame)
      (setq notmuch-mua-compose-in 'current-window))
    (if mu4e-compose-in-new-frame
      (setq mu4e-compose-in-new-frame nil)
      (setq mu4e-compose-in-new-frame t))))
#+END_SRC

This feeds a /text/calendar/ attachment into [[https://github.com/insanum/gcalcli][gcalcli]].

#+BEGIN_SRC emacs-lisp
  (defun sf/mu4e-view-gcal-attachment (msg attachnum)
    "Feed MSG's attachment ATTACHNUM through gcal-import"
    (let* ((att (mu4e~view-get-attach msg attachnum))
            (pipecmd "gcal-import")
            (index (plist-get att :index)))
      (mu4e~view-temp-action
        (mu4e-message-field msg :docid) index "pipe" pipecmd)))

#+END_SRC

A helper for extracting all attachments in a message.

#+BEGIN_SRC emacs-lisp
  (defun sf/mu4e-save-all-attachments (&optional msg)
    "Save all attachments in `msg' to a sub-directory
  in `mu4e-attachment-dir' location.  The sub-directory is
  derived from the subject of the email message."
    (interactive)
    (let* ((msg (or msg (mu4e-message-at-point)))
            (subject (message-wash-subject (mu4e-message-field msg :subject)))
            (attachdir (concat mu4e-attachment-dir "/" subject))
            (count (hash-table-count mu4e~view-attach-map)))
      (if (> count 0)
        (progn
          (mkdir attachdir t)
          (dolist (num (number-sequence 1 count))
            (let* ((att (mu4e~view-get-attach msg num))
                    (fname (plist-get att :name))
                    (index (plist-get att :index))
                    fpath)
              (setq fpath (expand-file-name (concat attachdir "/" fname)))
              (mu4e~proc-extract
                'save (mu4e-message-field msg :docid)
                index mu4e-decryption-policy fpath))))
        (message "Nothing to extract"))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun sf/mu4e-trash-add-sender-bulkdb (&optional msg)
  "Append sender to bulkdb file."
  (interactive)
  (let* ((msg (or msg (mu4e-message-at-point t)))
          (sender (mu4e-message-field msg :from))
          (buffer (buffer-local-value 'major-mode (current-buffer))))
    (write-region (concat (cdr (car sender)) "\n") nil (concat mu4e-maildir "/" ".bulk.db") 'append)
    (if (string-equal buffer "mu4e-view-mode") (mu4e-view-mark-for-trash) (mu4e-headers-mark-for-trash))))
#+END_SRC

** mu4e Maildirs Extension

[[https://github.com/agpchil/mu4e-maildirs-extension][mu4e-maildirs-extension]] is an extension that adds a maildir summary in
the =mu4e-main-view=.  While I don't presently use this, I've left this
for reference.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package mu4e-maildirs-extension
    :ensure t
    :defer 1
    :config
    (progn
      (mu4e-maildirs-extension)
      (setq
        mu4e-maildirs-extension-maildir-separator    "*"
        mu4e-maildirs-extension-submaildir-separator "✉"
        mu4e-maildirs-extension-action-text          nil)))
#+END_SRC

* Notmuch MUA

[[http://notmuchmail.org/][notmuch]] is basically a mail indexer.  It helps you to better tame your
inbox with search, tagging, and other functions.  There is a CLI
interface to interact with your email in Maildir format.  Or, you can
use the Emacs notmuch client front-end. 

While I am presently using /mu4e/, I have left the configuration here for reference.

Installation is basically:

#+BEGIN_EXAMPLE
$ brew install notmuch
#+END_EXAMPLE

Define various keybindings.

- https://github.com/Schnouki/dotfiles/blob/master/emacs/init-50-mail.el
- https://github.com/DamienCassou/emacs.d/blob/master/init.el

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package notmuch 
    :ensure notmuch
    :bind (:map notmuch-search-mode-map
            ("y" . notmuch-search-archive-thread)
            :map notmuch-show-mode-map
            ("y" . notmuch-show-archive-message-then-next-or-next-thread))
    :init
    (progn
      (setq
        notmuch-archive-tags '("-unread" "-trash" "+archive")
        notmuch-crypto-process-mime t
        notmuch-fcc-dirs sf-custom/fcc-dirs
        notmuch-hello-thousands-separator ","
        notmuch-search-oldest-first nil
        notmuch-show-part-button-default-action 'notmuch-show-view-part
        notmuch-saved-searches 
        '(
           (:name "Inbox"           :key "i" :query "tag:inbox and not tag:archive")
           (:name "Flagged"         :key "f" :query "tag:flagged")
           (:name "Today"           :key "t" :query "date:24h.. and not ( tag:archive or tag:sent )")
           (:name "3 days"          :key "3" :query "date:3d..  and not ( tag:archive or tag:sent )")
           (:name "14 days"         :key "4" :query "date:14d.. and not ( tag:archive or tag:sent ) ")
           (:name "Old messages"    :key "o" :query "date:..14d and not ( tag:archive or tag:sent ) and ( folder:Work/INBOX or folder:Work/incoming ) ")
           (:name "Needs attention" :key "!" :query "folder:Work/INBOX and ( tag:copyright or tag:flagged )")
           (:name "Sent"            :key "s" :query "folder:Work/Sent or tag:sent")
           (:name "Attachments"     :key "A" :query "tag:attachment")
           (:name "Meeting Invites" :key "c" :query "mimetype:text/calendar and not tag:archive")
           )
        )
      (add-to-list 'auto-mode-alist '("notmuch-raw-id" . markdown-mode))
      (add-hook 'notmuch-hello-mode-hook 'sf/nolinum)
      (add-hook 'notmuch-show-hook '(lambda () (setq show-trailing-whitespace nil)))
      (dolist (mode '(notmuch-search notmuch-show notmuch-tree-mode notmuch-help notmuch-message-mode))
        (evil-set-initial-state mode 'emacs))
      )
    :config
    (progn
      (define-key notmuch-show-mode-map (kbd "D")
        (lambda ()
          "mark message for trash"
          (interactive)
          (notmuch-show-add-tag '("+trash" "-inbox" "-unread" "-archive"))
          (unless (notmuch-show-next-open-message)
            (notmuch-show-next-thread t))))
      (define-key notmuch-search-mode-map (kbd "D")
        (lambda ()
          "mark thread for trash"
          (interactive)
          (notmuch-search-tag (list "+trash" "-inbox" "-unread" "-archive"))
          (notmuch-search-next-thread )))
      (define-key notmuch-show-mode-map (kbd "J")
        (lambda ()
          "mark message as junk"
          (interactive)
          (notmuch-show-add-tag (list "+bulk" "+trash" "-inbox" "-unread" "-archive"))
          (unless (notmuch-show-next-open-message)
            (notmuch-show-next-thread t))))
      (define-key notmuch-search-mode-map (kbd "J")
        (lambda ()
          "mark thread as junk"
          (interactive)
          (notmuch-search-tag (list "+bulk" "+trash" "-inbox" "-unread" "-archive"))
          (notmuch-search-next-thread )))
      (define-key notmuch-show-mode-map (kbd "F")
        (lambda ()
          "toggle message as flagged"
          (interactive)
          (if (member "flagged" (notmuch-show-get-tags))
            (notmuch-show-remove-tag (list "-flagged"))
            (notmuch-show-add-tag (list "+flagged")))))
      (define-key notmuch-search-mode-map (kbd "F")
        (lambda ()
          "toggle thread as flagged"
          (interactive)
          (if (member "flagged" (notmuch-search-get-tags))
            (notmuch-search-tag (list "-flagged"))
            (notmuch-search-tag (list "+flagged")))))
      (define-key notmuch-show-mode-map (kbd "M")
        (lambda ()
          "toggle message as muted"
          (interactive)
          (if (member "mute" (notmuch-show-get-tags))
            (notmuch-show-remove-tag (list "-mute"))
            (notmuch-show-add-tag (list "+mute")))))
      (define-key notmuch-search-mode-map (kbd "M")
        (lambda ()
          "toggle thread as muted"
          (interactive)
          (if (member "mute" (notmuch-search-get-tags))
            (notmuch-search-tag (list "-mute"))
            (notmuch-search-tag (list "+mute")))))        
      (define-key notmuch-show-mode-map (kbd "b")
        (lambda (&optional address)
          "Bounce the current message"
          (interactive "sBounce to: ")
          (notmuch-show-view-raw-message)
          (message-resend address)))
      (define-key notmuch-show-mode-map   (kbd "TAB") 'notmuch-show-toggle-message)
      (define-key notmuch-search-mode-map (kbd "g") 'notmuch-refresh-this-buffer)
      (define-key notmuch-hello-mode-map  (kbd "g") 'notmuch-refresh-this-buffer)
      (defun sf/notmuch-toggle-remote ()
        "Toggle whether to use notmuch remotely"
        (interactive)
        (if (string= notmuch-command "notmuch")
          (progn
            (setq notmuch-command "notmuch-remote.sh")
            (message "switching to remote notmuch"))
          (progn
            (setq notmuch-command "notmuch")
            (message "switching to local notmuch"))))
      ))
#+END_SRC

A series of helpers for forwarding emails.

#+BEGIN_SRC emacs-lisp :tangle no
  (defun sf/notmuch-attach-email (&optional path)
    "Attach a RFC822 email and give it a sensible file name"
    (interactive "sMessage path: ")
    (let ((newpath (expand-file-name (concat "~/tmp/" (number-to-string (truncate (float-time))) ".eml"))))
      (copy-file path newpath)
      (mml-attach-file newpath "message/rfc822" "" "attachment")))

  (defun sf/mail-forward-abuse-complaint ()
    "Forward an abuse complaint to responsible party"
    (interactive)
    (notmuch-show-forward-message)
    (message-goto-body)
    (yas-expand-snippet (yas-lookup-snippet "abuse-template"))
    (message-add-header (concat "Cc: " sf-custom/abuse-mail-cc))
    (message-goto-to))

  (defun sf/mail-forward-infringement-complaint ()
    "Forward a infringement complaint to responsible party"
    (interactive)
    (notmuch-show-forward-message)
    (message-goto-body)
    (yas-expand-snippet (yas-lookup-snippet "infringement-template"))
    (message-add-header (concat "Cc: " sf-custom/abuse-mail-cc))
    (message-goto-to))

  (defun sf/mail-forward-spam-complaint ()
    "Forward a spam complaint to responsible party"
    (interactive)
    (notmuch-show-forward-message)
    (message-goto-body)
    (yas-expand-snippet (yas-lookup-snippet "spam-template"))
    (message-add-header (concat "Cc: " sf-custom/abuse-mail-cc))
    (message-goto-to))

#+END_SRC

Other email helpers.

#+BEGIN_SRC emacs-lisp :tangle no
  (defun sf/mail-toggle-compose-new-frame ()
    "Toggle whether to compose email in new frame"
    (interactive)
    (cond ((eq notmuch-mua-compose-in 'current-window)
            (setq notmuch-mua-compose-in 'new-frame))
          ((eq notmuch-mua-compose-in 'new-frame)
            (setq notmuch-mua-compose-in 'current-window))))

  (defun sf/mail-save-all-attachments (&optional msg)
    "Save all attachments in `msg' to a sub-directory
    in `mu4e-attachment-dir' location.  The sub-directory is
    derived from the subject of the email message."
    (interactive)
    (let* ((msg (or msg (mu4e-message-at-point)))
            (subject (message-wash-subject (notmuch-show-get-subject)))
            (attachdir (concat mu4e-attachment-dir "/" subject))
            (count (hash-table-count mu4e~view-attach-map)))
      (if (> count 0)
        (progn
          (mkdir attachdir t)
            (dolist (num (number-sequence 1 count))
              (let* ((att (mu4e~view-get-attach msg num))
                      (fname (plist-get att :name))
                      (index (plist-get att :index))
                      fpath)
                (setq fpath (expand-file-name (concat attachdir "/" fname)))
                (mu4e~proc-extract
                  'save (mu4e-message-field msg :docid)
                  index mu4e-decryption-policy fpath))))
          (message "Nothing to extract"))))
#+END_SRC

Put together a hydra to make it easy to access the functionality.

#+BEGIN_SRC emacs-lisp :tangle no
  (defhydra sf/hydra-email (:color blue)
      "
    _f_ Forward email         _N_ Toggle compose New frame
    _A_ Forward Abuse report  _S_ Forward Spam report
    _I_ Forward Infringement  _e_ Extract all attachments
    "
      ("f" notmuch-show-forward-message)
      ("A" sf/mail-forward-abuse-complaint)
      ("I" sf/mail-forward-infringement-complaint)
      ("S" sf/mail-forward-spam-complaint)
      ("N" sf/mail-toggle-compose-new-frame)
      ("e" sf/mu4e-save-all-attachments))

  (global-set-key (kbd "C-c m") 'sf/hydra-email/body)
#+END_SRC

Last, but not least, enable linking to messages from org-mode.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package org-notmuch)
#+END_SRC

* Potpourri

** Multiple identities

For some emacs mail environments, you use =gnus-alias.el= to manage
multiple accounts (aka identities) for sending email via Emacs.  A good
portion of this is based on [[http://notmuchmail.org/emacstips/#index17h2][notmuch emacstips]].  You can find
=gnus-alias.el= on [[http://www.emacswiki.org/emacs/gnus-alias.el][emacswiki]] (source) and ([[https://www.emacswiki.org/emacs/GnusAlias][documentation]]).  This is
particularly helpful when you need to set =X-Message-SMTP-Method= for
per account SMTP servers (see [[https://gnu.org/software/emacs/manual/html_node/message/Mail-Variables.html#Mail-Variables][documentation]]).

=gnus-alias-identity= takes a lot of arguments.  They are briefly
described below.

1. Account nickname
2. Other identity it may refer to
3. Sender address
4. Organization header
5. Extra headers
6. Extra body text
7. Signature file

#+BEGIN_EXAMPLE
(setq gnus-alias-identity alist
  '(("gmail" nil "Joe Smith <jsmith@example.net>" nil nil nil nil))
  )
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
  (use-package gnus-alias
    :ensure t
    :init
    (progn
      (setq
        gnus-alias-default-identity "work"
        gnus-alias-identity-alist sf-custom/gnus-alias-alist
        gnus-alias-identity-rules sf-custom/gnus-alias-identity-rules
        )
      (add-hook 'message-setup-hook 'gnus-alias-determine-identity)
      )
    )
#+END_SRC

Finally, offer module for use.

#+BEGIN_SRC emacs-lisp
(provide 'setup-mail)
#+END_SRC
* License

This document is licensed under the GNU Free Documentation License
version 1.3 or later (http://www.gnu.org/copyleft/fdl.html).

#+BEGIN_SRC 
Copyright (C) 2017 Stephen Fromm

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.

Code in this document is free software: you can redistribute it
and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation, either
version 3 of the License, or (at your option) any later version.

This code is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
#+END_SRC
